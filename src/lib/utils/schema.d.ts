/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
	"/api/users/invalidate_token": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		post?: never;
		/**
		 * Invalidate Token
		 * @description Invalidate the local token with the provided id. Doesn't work for OIDC tokens. After calling this route the token with the provided id can't be used anymore.
		 */
		delete: operations["invalidate_token_api_users_invalidate_token_delete"];
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/users/invalidate_all_tokens": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		post?: never;
		/**
		 * Invalidate All Tokens
		 * @description Invalidate all local tokens of the logged in user account. Doesn't work for OIDC tokens. After calling this route all local tokens of the logged in user account won't work anymore.
		 */
		delete: operations["invalidate_all_tokens_api_users_invalidate_all_tokens_delete"];
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/users/get_new_api_token": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		/**
		 * Get New Api Token
		 * @description Create a new API token. The main difference between API tokens and the JWT tokens that you get after login is that API tokens never expire. Only create them if necessary and only use a different token for each device/service so that it is easy to invalidate one of them if a device gets compromised. The provided name has the purpose of being able to identify which token belongs to which device/service.THe successfuly response contains the newly created token.
		 */
		post: operations["get_new_api_token_api_users_get_new_api_token_post"];
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/users/get_all_token_info": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/**
		 * Get All Token Info
		 * @description Get a list of all token id's and names currently in use by this account. Temporary tokens created by the login route all share the same id and this id is marked as such. All other id's/names refer to API tokens that the user explicitly created using the get_new_api_token route.
		 */
		get: operations["get_all_token_info_api_users_get_all_token_info_get"];
		put?: never;
		post?: never;
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/users/info": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/**
		 * User Info
		 * @description This route returns all information about the currently logged in user. In addition to the information that is encoded in the JWT token itself (which the client could just extract on its own) it also returns information from the database and replaces iss/sub information with the provider name and account type of the user (local/ldap/oidc).
		 */
		get: operations["user_info_api_users_info_get"];
		put?: never;
		post?: never;
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/users/accept_tos": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		/**
		 * Accept Tos
		 * @description By calling this route the user accepts to the terms of service specified by the submitted tos_id and tos_version. Only if a user has accepted the newest version of every term of service of this instance they are allowed to use this service.
		 */
		post: operations["accept_tos_api_users_accept_tos_post"];
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/users/delete": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		post?: never;
		/**
		 * Delete User
		 * @description Deletes the currently logged in user and all information related to it (like jobs, tokens, etc.)
		 */
		delete: operations["delete_user_api_users_delete_delete"];
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/admins/create_runner": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		/**
		 * Create Runner
		 * @description Create a new global runner that can be used by all users of this instance. Returns the id and the runner token of the newly created runner. Put this token into the config file of the runner that you are trying to host. Create a new runner token for each new runner that you want to host using this route!
		 */
		post: operations["create_runner_api_admins_create_runner_post"];
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/admins/invalidate_runner": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		post?: never;
		/**
		 * Invalidate Runner
		 * @description Invalidate the token of a runner and delete it from the database and redis. If it has any jobs assigned at the time of invalidation these jobs will be reassigned to a different runner. Call this route immediately ones you find out that a runner token was compromised!
		 */
		delete: operations["invalidate_runner_api_admins_invalidate_runner_delete"];
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/jobs/submit_settings": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		/**
		 * Submit Settings
		 * @description Submit a new job settings object to the backend. If is_new_default is set to True this set of job settings will become the new default for this account and if no job settings object is specified during job submission this set of settings will be used. If it is set to False then this set of settings will only be used if specified explicitly during job submission. Returns the id of the newly created job settings object which can then be used to reference these job settings during job submission.
		 */
		post: operations["submit_settings_api_jobs_submit_settings_post"];
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/jobs/default_settings": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/**
		 * Get Default Settings
		 * @description Returns the default job settings of the current account. If no job settings id is explicitly specified during job submission then these job settings will be used for the job. These job settings where either set previously using the submit_settings route or are the application defaults.
		 */
		get: operations["get_default_settings_api_jobs_default_settings_get"];
		put?: never;
		post?: never;
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/jobs/submit_job": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		/**
		 * Submit Job
		 * @description Submit a new transcription job. If the job_settings_id is omitted the account defaults will be used.
		 *     If you want to define the job settings then create a job settings object using the submit_settings route and then set job_settings_id here to the returned integer.
		 *     Returns the id of the newly created job.
		 */
		post: operations["submit_job_api_jobs_submit_job_post"];
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/jobs/count": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/**
		 * Job Count
		 * @description Returns the total amount of jobs this user has after applying the provided filter options.
		 *     exclude_finished excludes finished jobs (both successful and aborted) while exclude_downloaded excludes finished jobs where the transcript was already downloaded at least ones.
		 */
		get: operations["job_count_api_jobs_count_get"];
		put?: never;
		post?: never;
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/jobs/get": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/**
		 * Get
		 * @description Returns a list of job ids sorted and filtered by the specified criteria.
		 *     start_index and end_index specify which jobs to return from the sorted list, e.g. a start_index of 0 and end_index of 9 will return the first 10 jobs, while a start_index of 10 and and end_index of 19 will return the next 10 and so on.
		 */
		get: operations["get_api_jobs_get_get"];
		put?: never;
		post?: never;
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/jobs/info": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/**
		 * Job Info
		 * @description Returns a list of job objects containing all information related to each of the specified jobs.
		 *     Note that job infos will be returned in no specific order, please use the get route to get an ordering of jobs by id and only use this route to get additional information about these jobs.
		 */
		get: operations["job_info_api_jobs_info_get"];
		put?: never;
		post?: never;
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/jobs/abort": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		/**
		 * Abort Jobs
		 * @description Aborts a currently running job. This will put the job into a failed state with an error message saying that the job was aborted. Any processing of this job will be canceled.
		 */
		post: operations["abort_jobs_api_jobs_abort_post"];
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/jobs/delete": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		post?: never;
		/**
		 * Delete Jobs
		 * @description Deletes a completed (aborted/successfully finished) job. To delete a currently running job please use the abort route first and then delete it using this route.
		 */
		delete: operations["delete_jobs_api_jobs_delete_delete"];
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/jobs/download_transcript": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/**
		 * Download Transcript
		 * @description Downloads the transcript of a successfully finished job. The transcript can be downloaded in multiple formats.
		 *     Returns the transcript as a string.
		 */
		get: operations["download_transcript_api_jobs_download_transcript_get"];
		put?: never;
		post?: never;
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/jobs/events": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/**
		 * Events
		 * @description This is a special route for subscribing to server-sent events (SSE).
		 *     Currently there is only one type of event called 'job_updated'. It returns the job id of a currently running job which attributes (e.g. processing step, progress, assigned runner, ...) have changed. This event can be used to only fetch job info using the info route when it actually has changed without having to periodically re-fetch the job info of all jobs.
		 */
		get: operations["events_api_jobs_events_get"];
		put?: never;
		post?: never;
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/runners/register": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		/**
		 * Register
		 * @description Registers the runner with the given runner_id as online.
		 *     Starting from the registration, the runner must periodically send
		 *     heartbeat requests to the manager, or it may be unregistered.
		 *     Returns the runner id on success.
		 */
		post: operations["register_api_runners_register_post"];
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/runners/unregister": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		/**
		 * Unregister Runner
		 * @description Unregisters an online runner. This will mark the runner as offline and no heartbeat or similar request will be possible anymore until another register request was performed.
		 */
		post: operations["unregister_runner_api_runners_unregister_post"];
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/runners/retrieve_job_info": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/**
		 * Retrieve Job Info
		 * @description The runner can retrieve metadata about the job that was assigned to it. This includes e.g. the job settings. The runner should call this route BEFORE it calls retrieve_job_audio to first make sure it can process the job. retrieve_job_info doesn't mark the job as running yet, only retrieve_job_audio will do that.
		 */
		get: operations["retrieve_job_info_api_runners_retrieve_job_info_get"];
		put?: never;
		post?: never;
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/runners/retrieve_job_audio": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		/**
		 * Retrieve Job Audio
		 * @description The runner streams the audio binary data of the job it got assigned over this route.
		 *     Additionally this route will mark the job a currently being processed by this runner.
		 *     Before callling this route the runner should have called retrieve_job_info first.
		 */
		post: operations["retrieve_job_audio_api_runners_retrieve_job_audio_post"];
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/runners/submit_job_result": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		/**
		 * Submit Job Result
		 * @description The runner submits the result of processing the job it got assigned over this route. The result can either be that the job failed (in which case the runner submits an error message) or that the job was successful (in which case the runner submits the transcript in all possible formats). This route will mark the job as failed or successful and notify the user over email if they activated email notifications for this job.
		 */
		post: operations["submit_job_result_api_runners_submit_job_result_post"];
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/runners/heartbeat": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		/**
		 * Heartbeat
		 * @description The heartbeat route that the runner has to periodically call to not be unregistered automatically by the backend. Over the response of this route the runner will also be notified about a new job that it got assigned or an abort request for a job the runner is currently processing.
		 */
		post: operations["heartbeat_api_runners_heartbeat_post"];
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/about": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/**
		 * About
		 * @description Returns a brief description of Project-W, a link to the backend's GitHub repository, the backend's version currently running on the system as well as the imprint of this instance (if it was configured by the instance's admin).
		 */
		get: operations["about_api_about_get"];
		put?: never;
		post?: never;
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/auth_settings": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/**
		 * Auth Settings
		 * @description Returns all information required by the client regarding which account types and identity providers this instance supports, whether account signup of local accounts is allowed, whether the creation of API tokens is allowed for each account type and so on.
		 */
		get: operations["auth_settings_api_auth_settings_get"];
		put?: never;
		post?: never;
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/oidc/login/{idp_name}": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/**
		 * Oidc-Redirect
		 * @description Start an OIDC login flow. This route will redirect you to the login page of the identity provider 'idp_name'. This name was specified by the admin in the config of this instance. Use the /api/auth_settings route to get the authentication-related configuration of this instance.
		 */
		get: operations["oidc_redirect_api_oidc_login__idp_name__get"];
		put?: never;
		post?: never;
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/oidc/auth/{idp_name}": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/**
		 * Oidc-Auth
		 * @description Landing route: After authenticating on the login page of the identity provider the provider will redirect you to this route so that the backend can process the IdP's response. This route will then redirect you to the official client's page (as set by the instance's admin) so that the client can get and store the OIDC id_token.
		 */
		get: operations["oidc_auth_api_oidc_auth__idp_name__get"];
		put?: never;
		post?: never;
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/ldap/login/{idp_name}": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		/**
		 * Login
		 * @description Log in with an LDAP user queried from the LDAP server with the name 'idp_name'. This name was specified by the admin in the config of this instance. Use the /api/auth_settings route to get the authentication-related configuration of this instance.
		 *     If logging in with an admin account the returned JWT token will not give you admin privileges by default. If you need a token with admin privileges then specify the scope 'admin' during login.
		 */
		post: operations["login_api_ldap_login__idp_name__post"];
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/local-account/login": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		/**
		 * Login
		 * @description Log in to an existing local Project-W account. This is an OAuth2 compliant password request form where the username is the user's email address. A successful response will contain a token that needs to be attached in the authentication header of responses for routes that require the user to be logged in.
		 *     If logging in with an admin account the returned JWT token will not give you admin privileges by default. If you need a token with admin privileges then specify the scope 'admin' during login.
		 */
		post: operations["login_api_local_account_login_post"];
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/local-account/signup": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		/**
		 * Signup
		 * @description Create a new local Project-W account. The provided email must be valid and the password must adhere to certain criteria (must contain at least one lowercase letter, uppercase letter, number, special character and at least 12 characters in total) and the email can't already be in use by another account.
		 */
		post: operations["signup_api_local_account_signup_post"];
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/local-account/activate": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		/**
		 * Activate
		 * @description Activate a local Project-W account, meaning validate it's email address. The token was sent to the user on account creation, email address change or when they specifically requested an email with the resend_activation_email route. Only activated users are able to submit transcription jobs and actually use this service.
		 */
		post: operations["activate_api_local_account_activate_post"];
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/local-account/resend_activation_email": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/**
		 * Resend Activation Email
		 * @description This will resend an activation email to the user like the one the user got when their account was created. Useful if they forgot to click on the link and lost the old email. Can only be requested if the user is not verified yet.
		 */
		get: operations["resend_activation_email_api_local_account_resend_activation_email_get"];
		put?: never;
		post?: never;
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/local-account/request_password_reset": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/**
		 * Request Password Reset
		 * @description Requests a password reset email that will be sent to the user containing a link to a password reset page. The provided email address must belong to an existing local Project-W account.
		 */
		get: operations["request_password_reset_api_local_account_request_password_reset_get"];
		put?: never;
		post?: never;
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/local-account/reset_password": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		/**
		 * Reset Password
		 * @description Resets the password of an account to the provided password. The token is the one from the password reset email that can be requested with the /request_password_reset route.
		 */
		post: operations["reset_password_api_local_account_reset_password_post"];
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/local-account/change_user_email": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		/**
		 * Change User Email
		 * @description Change the email address of a local Project-W account. This change will only take effect after the user has clicked on the link in the activation email that this route sends to the new email address.
		 */
		post: operations["change_user_email_api_local_account_change_user_email_post"];
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/api/local-account/change_user_password": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		/**
		 * Change User Password
		 * @description Change the password of a local Project-W account. In contrary to requesting a password reset email this route is authenticated meaning that to use this route the user must still be able to log in into their account, but it changes the password immediately without going through a link in an email first.
		 */
		post: operations["change_user_password_api_local_account_change_user_password_post"];
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
}
export type webhooks = Record<string, never>;
export interface components {
	schemas: {
		/** AboutResponse */
		AboutResponse: {
			/** Description */
			description: string;
			/** Source Code */
			source_code: string;
			/** Version */
			version: string;
			/** Git Hash */
			git_hash: string;
			imprint: components["schemas"]["ImprintSettings"] | null;
			/** Terms Of Services */
			terms_of_services: {
				[key: string]: components["schemas"]["TosSettings"];
			};
		};
		/** AlignmentProcessingSettings */
		AlignmentProcessingSettings: {
			/**
			 * Highlight Words
			 * @default false
			 */
			highlight_words: boolean;
			/** Max Line Count */
			max_line_count?: number | null;
			/** Max Line Width */
			max_line_width?: number | null;
		};
		/** AlignmentSettings */
		AlignmentSettings: {
			/** @default {
			 *       "highlight_words": false
			 *     } */
			processing: components["schemas"]["AlignmentProcessingSettings"];
			/**
			 * Return Char Alignments
			 * @default false
			 */
			return_char_alignments: boolean;
			/** @default nearest */
			interpolate_method: components["schemas"]["InterpolateMethodEnum"];
		};
		/** AsrSettings */
		AsrSettings: {
			/**
			 * Beam Size
			 * @default 5
			 */
			beam_size: number;
			/**
			 * Patience
			 * @default 1
			 */
			patience: number;
			/**
			 * Length Penalty
			 * @default 1
			 */
			length_penalty: number;
			/**
			 * Temperature
			 * @default 0
			 */
			temperature: number;
			/**
			 * Temperature Increment On Fallback
			 * @default 0.2
			 */
			temperature_increment_on_fallback: number;
			/**
			 * Compression Ratio Threshold
			 * @default 2.4
			 */
			compression_ratio_threshold: number;
			/**
			 * Log Prob Threshold
			 * @default -1
			 */
			log_prob_threshold: number;
			/**
			 * No Speech Threshold
			 * @default 0.6
			 */
			no_speech_threshold: number;
			/** Initial Prompt */
			initial_prompt?: string | null;
			/**
			 * Suppress Tokens
			 * @default [
			 *       -1
			 *     ]
			 */
			suppress_tokens: number[];
			/**
			 * Suppress Numerals
			 * @default false
			 */
			suppress_numerals: boolean;
		};
		/** AuthSettings */
		AuthSettings: {
			local_account: components["schemas"]["LocalAccountSettingsBase"];
			/** Oidc Providers */
			oidc_providers: {
				[key: string]: components["schemas"]["ProviderSettingsBase"];
			};
			/** Ldap Providers */
			ldap_providers: {
				[key: string]: components["schemas"]["ProviderSettingsBase"];
			};
		};
		/** Body_change_user_email_api_local_account_change_user_email_post */
		Body_change_user_email_api_local_account_change_user_email_post: {
			new_email: components["schemas"]["EmailValidated"];
			/**
			 * Password
			 * Format: password
			 */
			password: string;
		};
		/** Body_change_user_password_api_local_account_change_user_password_post */
		Body_change_user_password_api_local_account_change_user_password_post: {
			new_password: components["schemas"]["PasswordValidated"];
			/**
			 * Password
			 * Format: password
			 */
			password: string;
		};
		/** Body_login_api_ldap_login__idp_name__post */
		Body_login_api_ldap_login__idp_name__post: {
			/** Grant Type */
			grant_type?: string | null;
			/** Username */
			username: string;
			/** Password */
			password: string;
			/**
			 * Scope
			 * @default
			 */
			scope: string;
			/** Client Id */
			client_id?: string | null;
			/** Client Secret */
			client_secret?: string | null;
		};
		/** Body_login_api_local_account_login_post */
		Body_login_api_local_account_login_post: {
			/** Grant Type */
			grant_type?: string | null;
			/** Username */
			username: string;
			/** Password */
			password: string;
			/**
			 * Scope
			 * @default
			 */
			scope: string;
			/** Client Id */
			client_id?: string | null;
			/** Client Secret */
			client_secret?: string | null;
		};
		/** Body_submit_job_api_jobs_submit_job_post */
		Body_submit_job_api_jobs_submit_job_post: {
			/**
			 * Audio File
			 * Format: binary
			 */
			audio_file: string;
		};
		/** DiarizationSettings */
		DiarizationSettings: {
			/** Min Speakers */
			min_speakers?: number | null;
			/** Max Speakers */
			max_speakers?: number | null;
		};
		/** EmailValidated */
		EmailValidated: string;
		/**
		 * ErrorResponse
		 * @example {
		 *       "detail": "error message"
		 *     }
		 */
		ErrorResponse: {
			/** Detail */
			detail: string;
		};
		/** HTTPValidationError */
		HTTPValidationError: {
			/** Detail */
			detail?: components["schemas"]["ValidationError"][];
		};
		/** HeartbeatRequest */
		HeartbeatRequest: {
			/**
			 * Progress
			 * @default 0
			 */
			progress: number;
		};
		/** HeartbeatResponse */
		HeartbeatResponse: {
			/**
			 * Abort
			 * @default false
			 */
			abort: boolean;
			/**
			 * Job Assigned
			 * @default false
			 */
			job_assigned: boolean;
		};
		/** ImprintSettings */
		ImprintSettings: {
			/**
			 * Name
			 * @description The name of the person/institution hosting this instance
			 */
			name: string;
			/** @description The contact email address of the person/institution hosting this instance */
			email: components["schemas"]["EmailValidated"];
			/**
			 * Additional Imprint Html
			 * @description Content of the imprint in addition to the other fields
			 */
			additional_imprint_html?: string | null;
		};
		/**
		 * InterpolateMethodEnum
		 * @enum {string}
		 */
		InterpolateMethodEnum: "nearest" | "linear" | "ignore";
		/** JobInfo */
		JobInfo: {
			/** Id */
			id: number;
			/**
			 * Progress
			 * @default 0
			 */
			progress: number;
			/**
			 * Abort
			 * @default false
			 */
			abort: boolean;
			/**
			 * Creation Timestamp
			 * Format: date-time
			 */
			creation_timestamp: string;
			/** File Name */
			file_name: string;
			/** Finish Timestamp */
			finish_timestamp: string | null;
			/** Runner Name */
			runner_name: string | null;
			/** Runner Id */
			runner_id: number | null;
			/** Runner Version */
			runner_version: string | null;
			/** Runner Git Hash */
			runner_git_hash: string | null;
			/** Runner Source Code Url */
			runner_source_code_url: string | null;
			/** Downloaded */
			downloaded: boolean | null;
			/** Error Msg */
			error_msg: string | null;
			/** @default {
			 *       "task": "transcribe",
			 *       "model": "large",
			 *       "alignment": {
			 *         "interpolate_method": "nearest",
			 *         "processing": {
			 *           "highlight_words": false
			 *         },
			 *         "return_char_alignments": false
			 *       },
			 *       "vad_settings": {
			 *         "chunk_size": 30,
			 *         "vad_offset": 0.363,
			 *         "vad_onset": 0.5
			 *       },
			 *       "asr_settings": {
			 *         "beam_size": 5,
			 *         "compression_ratio_threshold": 2.4,
			 *         "length_penalty": 1,
			 *         "log_prob_threshold": -1,
			 *         "no_speech_threshold": 0.6,
			 *         "patience": 1,
			 *         "suppress_numerals": false,
			 *         "suppress_tokens": [
			 *           -1
			 *         ],
			 *         "temperature": 0,
			 *         "temperature_increment_on_fallback": 0.2
			 *       },
			 *       "email_notification": false
			 *     } */
			settings: components["schemas"]["JobSettings-Output"];
			step: components["schemas"]["JobStatus"];
		};
		/**
		 * JobLangEnum
		 * @enum {string}
		 */
		JobLangEnum:
			| "af"
			| "am"
			| "ar"
			| "as"
			| "az"
			| "ba"
			| "be"
			| "bg"
			| "bn"
			| "bo"
			| "br"
			| "bs"
			| "ca"
			| "cs"
			| "cy"
			| "da"
			| "de"
			| "el"
			| "en"
			| "es"
			| "et"
			| "eu"
			| "fa"
			| "fi"
			| "fo"
			| "fr"
			| "gl"
			| "gu"
			| "ha"
			| "haw"
			| "he"
			| "hi"
			| "hr"
			| "ht"
			| "hu"
			| "hy"
			| "id"
			| "is"
			| "it"
			| "ja"
			| "jw"
			| "ka"
			| "kk"
			| "km"
			| "kn"
			| "ko"
			| "la"
			| "lb"
			| "ln"
			| "lo"
			| "lt"
			| "lv"
			| "mg"
			| "mi"
			| "mk"
			| "ml"
			| "mn"
			| "mr"
			| "ms"
			| "mt"
			| "my"
			| "ne"
			| "nl"
			| "nn"
			| "no"
			| "oc"
			| "pa"
			| "pl"
			| "ps"
			| "pt"
			| "ro"
			| "ru"
			| "sa"
			| "sd"
			| "si"
			| "sk"
			| "sl"
			| "sn"
			| "so"
			| "sq"
			| "sr"
			| "su"
			| "sv"
			| "sw"
			| "ta"
			| "te"
			| "tg"
			| "th"
			| "tk"
			| "tl"
			| "tr"
			| "tt"
			| "uk"
			| "ur"
			| "uz"
			| "vi"
			| "yi"
			| "yo"
			| "yue"
			| "zh";
		/**
		 * JobModelEnum
		 * @enum {string}
		 */
		JobModelEnum:
			| "tiny"
			| "tiny.en"
			| "base"
			| "base.en"
			| "small"
			| "small.en"
			| "medium"
			| "medium.en"
			| "turbo"
			| "large";
		/** JobSettings */
		"JobSettings-Input": {
			/** @default transcribe */
			task: components["schemas"]["TaskEnum"];
			/** @default large */
			model: components["schemas"]["JobModelEnum"];
			language?: components["schemas"]["JobLangEnum"] | null;
			/** @default {
			 *       "processing": {
			 *         "highlight_words": false
			 *       },
			 *       "return_char_alignments": false,
			 *       "interpolate_method": "nearest"
			 *     } */
			alignment: components["schemas"]["AlignmentSettings"] | null;
			diarization?: components["schemas"]["DiarizationSettings"] | null;
			/** @default {
			 *       "vad_onset": 0.5,
			 *       "vad_offset": 0.363,
			 *       "chunk_size": 30
			 *     } */
			vad_settings: components["schemas"]["VadSettings"];
			/** @default {
			 *       "beam_size": 5,
			 *       "patience": 1,
			 *       "length_penalty": 1,
			 *       "temperature": 0,
			 *       "temperature_increment_on_fallback": 0.2,
			 *       "compression_ratio_threshold": 2.4,
			 *       "log_prob_threshold": -1,
			 *       "no_speech_threshold": 0.6,
			 *       "suppress_tokens": [
			 *         -1
			 *       ],
			 *       "suppress_numerals": false
			 *     } */
			asr_settings: components["schemas"]["AsrSettings"];
			/**
			 * Email Notification
			 * @default false
			 */
			email_notification: boolean;
		};
		/** JobSettings */
		"JobSettings-Output": {
			/** @default transcribe */
			task: components["schemas"]["TaskEnum"];
			/** @default large */
			model: components["schemas"]["JobModelEnum"];
			language?: components["schemas"]["JobLangEnum"] | null;
			/** @default {
			 *       "processing": {
			 *         "highlight_words": false
			 *       },
			 *       "return_char_alignments": false,
			 *       "interpolate_method": "nearest"
			 *     } */
			alignment: components["schemas"]["AlignmentSettings"] | null;
			diarization?: components["schemas"]["DiarizationSettings"] | null;
			/** @default {
			 *       "vad_onset": 0.5,
			 *       "vad_offset": 0.363,
			 *       "chunk_size": 30
			 *     } */
			vad_settings: components["schemas"]["VadSettings"];
			/** @default {
			 *       "beam_size": 5,
			 *       "patience": 1,
			 *       "length_penalty": 1,
			 *       "temperature": 0,
			 *       "temperature_increment_on_fallback": 0.2,
			 *       "compression_ratio_threshold": 2.4,
			 *       "log_prob_threshold": -1,
			 *       "no_speech_threshold": 0.6,
			 *       "suppress_tokens": [
			 *         -1
			 *       ],
			 *       "suppress_numerals": false
			 *     } */
			asr_settings: components["schemas"]["AsrSettings"];
			/**
			 * Email Notification
			 * @default false
			 */
			email_notification: boolean;
		};
		/** JobSettingsBase */
		JobSettingsBase: {
			/** @default transcribe */
			task: components["schemas"]["TaskEnum"];
			/** @default large */
			model: components["schemas"]["JobModelEnum"];
			language?: components["schemas"]["JobLangEnum"] | null;
			/** @default {
			 *       "processing": {
			 *         "highlight_words": false
			 *       },
			 *       "return_char_alignments": false,
			 *       "interpolate_method": "nearest"
			 *     } */
			alignment: components["schemas"]["AlignmentSettings"] | null;
			diarization?: components["schemas"]["DiarizationSettings"] | null;
			/** @default {
			 *       "vad_onset": 0.5,
			 *       "vad_offset": 0.363,
			 *       "chunk_size": 30
			 *     } */
			vad_settings: components["schemas"]["VadSettings"];
			/** @default {
			 *       "beam_size": 5,
			 *       "patience": 1,
			 *       "length_penalty": 1,
			 *       "temperature": 0,
			 *       "temperature_increment_on_fallback": 0.2,
			 *       "compression_ratio_threshold": 2.4,
			 *       "log_prob_threshold": -1,
			 *       "no_speech_threshold": 0.6,
			 *       "suppress_tokens": [
			 *         -1
			 *       ],
			 *       "suppress_numerals": false
			 *     } */
			asr_settings: components["schemas"]["AsrSettings"];
		};
		/**
		 * JobSortKey
		 * @enum {string}
		 */
		JobSortKey: "creation_time" | "filename";
		/**
		 * JobStatus
		 * @description Represents all the possible statuses that a
		 *     job request might have.
		 * @enum {string}
		 */
		JobStatus:
			| "not_queued"
			| "pending_runner"
			| "runner_assigned"
			| "runner_in_progress"
			| "aborting"
			| "success"
			| "failed"
			| "downloaded";
		/**
		 * LocalAccountOperationModeEnum
		 * @enum {string}
		 */
		LocalAccountOperationModeEnum:
			| "disabled"
			| "no-signup_hidden"
			| "no-signup"
			| "enabled";
		/** LocalAccountSettingsBase */
		LocalAccountSettingsBase: {
			/**
			 * @description
			 *             To what extend local accounts should be enabled.
			 *             - enabled: Both login and signup possible and advertised in frontend to users (default).
			 *             - no_signup: Login possible and advertised to users, signup not. Thus users can only login using already existing accounts (created through provisioning or by signup before this setting was set). Use this for example if you want users to login using local accounts that you created for them through provisioning.
			 *             - no_signup_hidden: Login still possible but not advertised to users in the frontend. Especially helpful if the only local accounts should be provisioned admin accounts for administration purposes while normal users should only login using oidc or ldap accounts.
			 *             - disabled: no login, no signup, no provisioned accounts. Login only through ldap and oidc. Please note that in this case you need to provide admin accounts through ldap or oidc as well!
			 *
			 * @default enabled
			 */
			mode: components["schemas"]["LocalAccountOperationModeEnum"];
			/**
			 * Allowed Email Domains
			 * @default []
			 */
			allowed_email_domains: string[];
			/**
			 * Allow Creation Of Api Tokens
			 * @description If set to true then users logged in with local accounts can create api tokens with infinite lifetime. They will get invalidated if the user gets deleted.
			 * @default true
			 */
			allow_creation_of_api_tokens: boolean;
		};
		/** PasswordResetData */
		PasswordResetData: {
			/**
			 * Token
			 * Format: password
			 */
			token: string;
			new_password: components["schemas"]["PasswordValidated"];
		};
		/**
		 * PasswordValidated
		 * Format: password
		 */
		PasswordValidated: string;
		/** ProviderSettingsBase */
		ProviderSettingsBase: {
			/**
			 * Hidden
			 * @description Whether this provider should not be advertised to the user on the frontend. Useful if this provider should only provide admin accounts.
			 * @default false
			 */
			hidden: boolean;
			/**
			 * Icon Url
			 * @description URL to a square icon that will be shown to the user in the frontend next to the 'Login with <name>' to visually represent the account/identity provider. Should be a link to a square png with transparent background, or alternatively to a svg
			 */
			icon_url?: string | null;
			/**
			 * Allow Creation Of Api Tokens
			 * @description If set to true then users logged in from this identity provider can create api tokens with infinite lifetime. These tokens will not be automatically invalidated if the user gets deleted or looses permissions in the identity provider. This means that with this setting enabled, users that ones have access to Project-W can retain that access possibly forever. Consider if this is a problem for you before enabling this!
			 * @default false
			 */
			allow_creation_of_api_tokens: boolean;
		};
		/** RegisteredResponse */
		RegisteredResponse: {
			/** Id */
			id: number;
			/** Session Token */
			session_token: string;
		};
		/** RunnerCreatedInfo */
		RunnerCreatedInfo: {
			/** Id */
			id: number;
			/** Token */
			token: string;
		};
		/** RunnerJobInfoResponse */
		RunnerJobInfoResponse: {
			/** Id */
			id: number;
			settings: components["schemas"]["JobSettingsBase"];
		};
		/** RunnerRegisterRequest */
		RunnerRegisterRequest: {
			/** Name */
			name: string;
			/** Version */
			version: string;
			/** Git Hash */
			git_hash: string;
			/** Source Code Url */
			source_code_url: string;
			/** Priority */
			priority: number;
		};
		/** RunnerSubmitResultRequest */
		RunnerSubmitResultRequest: {
			/** Error Msg */
			error_msg?: string | null;
			transcript?: components["schemas"]["Transcript"] | null;
		};
		/** SignupData */
		SignupData: {
			email: components["schemas"]["EmailValidated"];
			password: components["schemas"]["PasswordValidated"];
		};
		/**
		 * TaskEnum
		 * @enum {string}
		 */
		TaskEnum: "transcribe" | "translate";
		/** TokenSecretInfo */
		TokenSecretInfo: {
			/** Id */
			id: number;
			/** Name */
			name: string | null;
			/** Temp Token Secret */
			temp_token_secret: boolean;
		};
		/** TosSettings */
		TosSettings: {
			/**
			 * Name
			 * @description The name of this term of service. This will be shown as a title above the tos_html content in the frontend
			 */
			name: string;
			/**
			 * Version
			 * @description The version of this term of service. Start by putting this to 1. When incremented then users will have to re-accept these terms.
			 */
			version: number;
			/**
			 * Tos Html
			 * @description The terms of services in html format. You may include links to external websites if you want.
			 */
			tos_html: string;
		};
		/** Transcript */
		Transcript: {
			/** As Txt */
			as_txt: string;
			/** As Srt */
			as_srt: string;
			/** As Tsv */
			as_tsv: string;
			/** As Vtt */
			as_vtt: string;
			/** As Json */
			as_json: {
				[key: string]: unknown;
			};
		};
		/**
		 * TranscriptTypeEnum
		 * @enum {string}
		 */
		TranscriptTypeEnum: "as_txt" | "as_srt" | "as_tsv" | "as_vtt" | "as_json";
		/** User */
		User: {
			/** Accepted Tos */
			accepted_tos: {
				[key: string]: number;
			};
			/** Id */
			id: number;
			email: components["schemas"]["EmailValidated"];
			/** Provider Name */
			provider_name: string;
			user_type: components["schemas"]["UserTypeEnum"];
			/** Is Admin */
			is_admin: boolean;
			/** Is Verified */
			is_verified: boolean;
		};
		/**
		 * UserTypeEnum
		 * @enum {string}
		 */
		UserTypeEnum: "local" | "ldap" | "oidc";
		/** VadSettings */
		VadSettings: {
			/**
			 * Vad Onset
			 * @default 0.5
			 */
			vad_onset: number;
			/**
			 * Vad Offset
			 * @default 0.363
			 */
			vad_offset: number;
			/**
			 * Chunk Size
			 * @default 30
			 */
			chunk_size: number;
		};
		/** ValidationError */
		ValidationError: {
			/** Location */
			loc: (string | number)[];
			/** Message */
			msg: string;
			/** Error Type */
			type: string;
		};
	};
	responses: never;
	parameters: never;
	requestBodies: never;
	headers: never;
	pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
	invalidate_token_api_users_invalidate_token_delete: {
		parameters: {
			query: {
				token_id: number;
			};
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": string;
				};
			};
			/** @description Validation error of JWT token */
			401: {
				headers: {
					"WWW-Authenticate"?: unknown;
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
			/** @description Token doesn't grand enough permissions */
			403: {
				headers: {
					"WWW-Authenticate"?: unknown;
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["HTTPValidationError"];
				};
			};
		};
	};
	invalidate_all_tokens_api_users_invalidate_all_tokens_delete: {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": string;
				};
			};
			/** @description Validation error of JWT token */
			401: {
				headers: {
					"WWW-Authenticate"?: unknown;
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
			/** @description Token doesn't grand enough permissions */
			403: {
				headers: {
					"WWW-Authenticate"?: unknown;
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
		};
	};
	get_new_api_token_api_users_get_new_api_token_post: {
		parameters: {
			query: {
				name: string;
			};
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": string;
				};
			};
			/** @description Creation of api tokens is disabled for your identity provider */
			400: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
			/** @description Validation error of JWT token */
			401: {
				headers: {
					"WWW-Authenticate"?: unknown;
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
			/** @description Token doesn't grand enough permissions */
			403: {
				headers: {
					"WWW-Authenticate"?: unknown;
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["HTTPValidationError"];
				};
			};
		};
	};
	get_all_token_info_api_users_get_all_token_info_get: {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["TokenSecretInfo"][];
				};
			};
			/** @description Validation error of JWT token */
			401: {
				headers: {
					"WWW-Authenticate"?: unknown;
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
			/** @description Token doesn't grand enough permissions */
			403: {
				headers: {
					"WWW-Authenticate"?: unknown;
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
		};
	};
	user_info_api_users_info_get: {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["User"];
				};
			};
			/** @description Validation error of JWT token */
			401: {
				headers: {
					"WWW-Authenticate"?: unknown;
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
			/** @description Token doesn't grand enough permissions */
			403: {
				headers: {
					"WWW-Authenticate"?: unknown;
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
		};
	};
	accept_tos_api_users_accept_tos_post: {
		parameters: {
			query: {
				tos_id: number;
				tos_version: number;
			};
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": string;
				};
			};
			/** @description No term of service with that id or version exists */
			400: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
			/** @description Validation error of JWT token */
			401: {
				headers: {
					"WWW-Authenticate"?: unknown;
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
			/** @description Token doesn't grand enough permissions */
			403: {
				headers: {
					"WWW-Authenticate"?: unknown;
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["HTTPValidationError"];
				};
			};
		};
	};
	delete_user_api_users_delete_delete: {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": string;
				};
			};
			/** @description Validation error of JWT token */
			401: {
				headers: {
					"WWW-Authenticate"?: unknown;
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
			/** @description Token doesn't grand enough permissions */
			403: {
				headers: {
					"WWW-Authenticate"?: unknown;
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
		};
	};
	create_runner_api_admins_create_runner_post: {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["RunnerCreatedInfo"];
				};
			};
			/** @description Validation error of JWT token */
			401: {
				headers: {
					"WWW-Authenticate"?: unknown;
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
			/** @description Token doesn't grand enough permissions */
			403: {
				headers: {
					"WWW-Authenticate"?: unknown;
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
		};
	};
	invalidate_runner_api_admins_invalidate_runner_delete: {
		parameters: {
			query: {
				runner_id: number;
			};
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": string;
				};
			};
			/** @description Validation error of JWT token */
			401: {
				headers: {
					"WWW-Authenticate"?: unknown;
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
			/** @description Token doesn't grand enough permissions */
			403: {
				headers: {
					"WWW-Authenticate"?: unknown;
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["HTTPValidationError"];
				};
			};
		};
	};
	submit_settings_api_jobs_submit_settings_post: {
		parameters: {
			query?: {
				is_new_default?: boolean;
			};
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody: {
			content: {
				"application/json": components["schemas"]["JobSettings-Input"];
			};
		};
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": number;
				};
			};
			/** @description Validation error of JWT token */
			401: {
				headers: {
					"WWW-Authenticate"?: unknown;
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
			/** @description Token doesn't grand enough permissions */
			403: {
				headers: {
					"WWW-Authenticate"?: unknown;
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["HTTPValidationError"];
				};
			};
		};
	};
	get_default_settings_api_jobs_default_settings_get: {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["JobSettings-Output"];
				};
			};
			/** @description Validation error of JWT token */
			401: {
				headers: {
					"WWW-Authenticate"?: unknown;
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
			/** @description Token doesn't grand enough permissions */
			403: {
				headers: {
					"WWW-Authenticate"?: unknown;
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
		};
	};
	submit_job_api_jobs_submit_job_post: {
		parameters: {
			query?: {
				job_settings_id?: number | null;
			};
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody: {
			content: {
				"multipart/form-data": components["schemas"]["Body_submit_job_api_jobs_submit_job_post"];
			};
		};
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": number;
				};
			};
			/** @description Not an audio file or provided job_settings_id was invalid */
			400: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
			/** @description Validation error of JWT token */
			401: {
				headers: {
					"WWW-Authenticate"?: unknown;
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
			/** @description Token doesn't grand enough permissions */
			403: {
				headers: {
					"WWW-Authenticate"?: unknown;
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["HTTPValidationError"];
				};
			};
		};
	};
	job_count_api_jobs_count_get: {
		parameters: {
			query: {
				exclude_finished: boolean;
				exclude_downloaded: boolean;
			};
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": number;
				};
			};
			/** @description Validation error of JWT token */
			401: {
				headers: {
					"WWW-Authenticate"?: unknown;
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
			/** @description Token doesn't grand enough permissions */
			403: {
				headers: {
					"WWW-Authenticate"?: unknown;
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["HTTPValidationError"];
				};
			};
		};
	};
	get_api_jobs_get_get: {
		parameters: {
			query: {
				start_index: number;
				end_index: number;
				sort_key: components["schemas"]["JobSortKey"];
				descending: boolean;
				exclude_finished: boolean;
				exclude_downloaded: boolean;
			};
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": number[];
				};
			};
			/** @description Validation error of JWT token */
			401: {
				headers: {
					"WWW-Authenticate"?: unknown;
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
			/** @description Token doesn't grand enough permissions */
			403: {
				headers: {
					"WWW-Authenticate"?: unknown;
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["HTTPValidationError"];
				};
			};
		};
	};
	job_info_api_jobs_info_get: {
		parameters: {
			query: {
				job_ids: number[];
			};
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["JobInfo"][];
				};
			};
			/** @description Validation error of JWT token */
			401: {
				headers: {
					"WWW-Authenticate"?: unknown;
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
			/** @description Token doesn't grand enough permissions */
			403: {
				headers: {
					"WWW-Authenticate"?: unknown;
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["HTTPValidationError"];
				};
			};
		};
	};
	abort_jobs_api_jobs_abort_post: {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody: {
			content: {
				"application/json": number[];
			};
		};
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": string;
				};
			};
			/** @description At least one of jobs is not running */
			400: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
			/** @description Validation error of JWT token */
			401: {
				headers: {
					"WWW-Authenticate"?: unknown;
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
			/** @description Token doesn't grand enough permissions */
			403: {
				headers: {
					"WWW-Authenticate"?: unknown;
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["HTTPValidationError"];
				};
			};
		};
	};
	delete_jobs_api_jobs_delete_delete: {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody: {
			content: {
				"application/json": number[];
			};
		};
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": string;
				};
			};
			/** @description At least one of jobs is running */
			400: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
			/** @description Validation error of JWT token */
			401: {
				headers: {
					"WWW-Authenticate"?: unknown;
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
			/** @description Token doesn't grand enough permissions */
			403: {
				headers: {
					"WWW-Authenticate"?: unknown;
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["HTTPValidationError"];
				};
			};
		};
	};
	download_transcript_api_jobs_download_transcript_get: {
		parameters: {
			query: {
				job_id: number;
				transcript_type: components["schemas"]["TranscriptTypeEnum"];
			};
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json":
						| string
						| {
								[key: string]: unknown;
						  };
				};
			};
			/** @description No job with that id exists or that job isn't finished */
			400: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
			/** @description Validation error of JWT token */
			401: {
				headers: {
					"WWW-Authenticate"?: unknown;
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
			/** @description Token doesn't grand enough permissions */
			403: {
				headers: {
					"WWW-Authenticate"?: unknown;
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["HTTPValidationError"];
				};
			};
		};
	};
	events_api_jobs_events_get: {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": unknown;
				};
			};
			/** @description Validation error of JWT token */
			401: {
				headers: {
					"WWW-Authenticate"?: unknown;
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
			/** @description Token doesn't grand enough permissions */
			403: {
				headers: {
					"WWW-Authenticate"?: unknown;
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
		};
	};
	register_api_runners_register_post: {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody: {
			content: {
				"application/json": components["schemas"]["RunnerRegisterRequest"];
			};
		};
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["RegisteredResponse"];
				};
			};
			/** @description No runner with that token exists */
			401: {
				headers: {
					"WWW-Authenticate"?: unknown;
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
			/** @description This runner is currently already registered as online */
			403: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["HTTPValidationError"];
				};
			};
		};
	};
	unregister_runner_api_runners_unregister_post: {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": string;
				};
			};
			/** @description No runner with that token exists */
			401: {
				headers: {
					"WWW-Authenticate"?: unknown;
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
		};
	};
	retrieve_job_info_api_runners_retrieve_job_info_get: {
		parameters: {
			query: {
				session_token: string;
			};
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["RunnerJobInfoResponse"];
				};
			};
			/** @description No job assigned or job not in database */
			400: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
			/** @description No runner with that token exists */
			401: {
				headers: {
					"WWW-Authenticate"?: unknown;
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
			/** @description This runner is currently not registered as online, or session_token is invalid */
			403: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
			/** @description The assigned job was aborted by the user */
			405: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["HTTPValidationError"];
				};
			};
		};
	};
	retrieve_job_audio_api_runners_retrieve_job_audio_post: {
		parameters: {
			query: {
				session_token: string;
			};
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": unknown;
				};
			};
			/** @description No job assigned */
			400: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
			/** @description No runner with that token exists */
			401: {
				headers: {
					"WWW-Authenticate"?: unknown;
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
			/** @description This runner is currently not registered as online, or session_token is invalid */
			403: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
			/** @description The assigned job was aborted by the user */
			405: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["HTTPValidationError"];
				};
			};
		};
	};
	submit_job_result_api_runners_submit_job_result_post: {
		parameters: {
			query: {
				session_token: string;
			};
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody: {
			content: {
				"application/json": components["schemas"]["RunnerSubmitResultRequest"];
			};
		};
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": string;
				};
			};
			/** @description Runner not processing a job */
			400: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
			/** @description No runner with that token exists */
			401: {
				headers: {
					"WWW-Authenticate"?: unknown;
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
			/** @description This runner is currently not registered as online, or session_token is invalid */
			403: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["HTTPValidationError"];
				};
			};
		};
	};
	heartbeat_api_runners_heartbeat_post: {
		parameters: {
			query: {
				session_token: string;
			};
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody: {
			content: {
				"application/json": components["schemas"]["HeartbeatRequest"];
			};
		};
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["HeartbeatResponse"];
				};
			};
			/** @description No runner with that token exists */
			401: {
				headers: {
					"WWW-Authenticate"?: unknown;
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
			/** @description This runner is currently not registered as online, or session_token is invalid */
			403: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["HTTPValidationError"];
				};
			};
		};
	};
	about_api_about_get: {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["AboutResponse"];
				};
			};
		};
	};
	auth_settings_api_auth_settings_get: {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["AuthSettings"];
				};
			};
		};
	};
	oidc_redirect_api_oidc_login__idp_name__get: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				idp_name: string;
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": unknown;
				};
			};
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["HTTPValidationError"];
				};
			};
		};
	};
	oidc_auth_api_oidc_auth__idp_name__get: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				idp_name: string;
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": unknown;
				};
			};
			/** @description Could not authorize IdP access token */
			400: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
			/** @description Validation error of id_token */
			401: {
				headers: {
					"WWW-Authenticate"?: unknown;
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
			/** @description Not enough information or missing scope */
			403: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["HTTPValidationError"];
				};
			};
		};
	};
	login_api_ldap_login__idp_name__post: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				idp_name: string;
			};
			cookie?: never;
		};
		requestBody: {
			content: {
				"application/x-www-form-urlencoded": components["schemas"]["Body_login_api_ldap_login__idp_name__post"];
			};
		};
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": string;
				};
			};
			/** @description idp_name is invalid */
			400: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
			/** @description Authentication was unsuccessful */
			401: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["HTTPValidationError"];
				};
			};
		};
	};
	login_api_local_account_login_post: {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody: {
			content: {
				"application/x-www-form-urlencoded": components["schemas"]["Body_login_api_local_account_login_post"];
			};
		};
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": string;
				};
			};
			/** @description Authentication was unsuccessful */
			401: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["HTTPValidationError"];
				};
			};
		};
	};
	signup_api_local_account_signup_post: {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody: {
			content: {
				"application/json": components["schemas"]["SignupData"];
			};
		};
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": string;
				};
			};
			/** @description Email or password have invalid syntax */
			400: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
			/** @description Signup of new accounts is disabled on this server */
			405: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["HTTPValidationError"];
				};
			};
		};
	};
	activate_api_local_account_activate_post: {
		parameters: {
			query: {
				token: string;
			};
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": string;
				};
			};
			/** @description Activation token doesn't match any user, or user has already been activated */
			400: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
			/** @description Activation token invalid */
			401: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["HTTPValidationError"];
				};
			};
		};
	};
	resend_activation_email_api_local_account_resend_activation_email_get: {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": string;
				};
			};
			/** @description User is not a local Project-W user or has been provisioned through the config file */
			400: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
			/** @description Validation error of JWT token */
			401: {
				headers: {
					"WWW-Authenticate"?: unknown;
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
			/** @description Token doesn't grand enough permissions */
			403: {
				headers: {
					"WWW-Authenticate"?: unknown;
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
		};
	};
	request_password_reset_api_local_account_request_password_reset_get: {
		parameters: {
			query: {
				email: string;
			};
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": string;
				};
			};
			/** @description Email invalid */
			400: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["HTTPValidationError"];
				};
			};
		};
	};
	reset_password_api_local_account_reset_password_post: {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody: {
			content: {
				"application/json": components["schemas"]["PasswordResetData"];
			};
		};
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": string;
				};
			};
			/** @description Password reset token doesn't match any user */
			400: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
			/** @description Password reset token invalid */
			401: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["HTTPValidationError"];
				};
			};
		};
	};
	change_user_email_api_local_account_change_user_email_post: {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody: {
			content: {
				"application/json": components["schemas"]["Body_change_user_email_api_local_account_change_user_email_post"];
			};
		};
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": string;
				};
			};
			/** @description User is not a local Project-W user or has been provisioned through the config file */
			400: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
			/** @description Validation error of JWT token */
			401: {
				headers: {
					"WWW-Authenticate"?: unknown;
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
			/** @description Token doesn't grand enough permissions */
			403: {
				headers: {
					"WWW-Authenticate"?: unknown;
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["HTTPValidationError"];
				};
			};
		};
	};
	change_user_password_api_local_account_change_user_password_post: {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody: {
			content: {
				"application/json": components["schemas"]["Body_change_user_password_api_local_account_change_user_password_post"];
			};
		};
		responses: {
			/** @description Successful Response */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": string;
				};
			};
			/** @description User is not a local Project-W user or has been provisioned through the config file */
			400: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
			/** @description Validation error of JWT token */
			401: {
				headers: {
					"WWW-Authenticate"?: unknown;
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
			/** @description Token doesn't grand enough permissions */
			403: {
				headers: {
					"WWW-Authenticate"?: unknown;
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
			/** @description Validation Error */
			422: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					"application/json": components["schemas"]["HTTPValidationError"];
				};
			};
		};
	};
}
type ReadonlyArray<T> = [Exclude<T, undefined>] extends [unknown[]]
	? Readonly<Exclude<T, undefined>>
	: Readonly<Exclude<T, undefined>[]>;
export const interpolateMethodEnumValues: ReadonlyArray<
	components["schemas"]["InterpolateMethodEnum"]
> = ["nearest", "linear", "ignore"];
export const jobLangEnumValues: ReadonlyArray<
	components["schemas"]["JobLangEnum"]
> = [
	"af",
	"am",
	"ar",
	"as",
	"az",
	"ba",
	"be",
	"bg",
	"bn",
	"bo",
	"br",
	"bs",
	"ca",
	"cs",
	"cy",
	"da",
	"de",
	"el",
	"en",
	"es",
	"et",
	"eu",
	"fa",
	"fi",
	"fo",
	"fr",
	"gl",
	"gu",
	"ha",
	"haw",
	"he",
	"hi",
	"hr",
	"ht",
	"hu",
	"hy",
	"id",
	"is",
	"it",
	"ja",
	"jw",
	"ka",
	"kk",
	"km",
	"kn",
	"ko",
	"la",
	"lb",
	"ln",
	"lo",
	"lt",
	"lv",
	"mg",
	"mi",
	"mk",
	"ml",
	"mn",
	"mr",
	"ms",
	"mt",
	"my",
	"ne",
	"nl",
	"nn",
	"no",
	"oc",
	"pa",
	"pl",
	"ps",
	"pt",
	"ro",
	"ru",
	"sa",
	"sd",
	"si",
	"sk",
	"sl",
	"sn",
	"so",
	"sq",
	"sr",
	"su",
	"sv",
	"sw",
	"ta",
	"te",
	"tg",
	"th",
	"tk",
	"tl",
	"tr",
	"tt",
	"uk",
	"ur",
	"uz",
	"vi",
	"yi",
	"yo",
	"yue",
	"zh",
];
export const jobModelEnumValues: ReadonlyArray<
	components["schemas"]["JobModelEnum"]
> = [
	"tiny",
	"tiny.en",
	"base",
	"base.en",
	"small",
	"small.en",
	"medium",
	"medium.en",
	"turbo",
	"large",
];
export const jobSortKeyValues: ReadonlyArray<
	components["schemas"]["JobSortKey"]
> = ["creation_time", "filename"];
export const jobStatusValues: ReadonlyArray<
	components["schemas"]["JobStatus"]
> = [
	"not_queued",
	"pending_runner",
	"runner_assigned",
	"runner_in_progress",
	"aborting",
	"success",
	"failed",
	"downloaded",
];
export const localAccountOperationModeEnumValues: ReadonlyArray<
	components["schemas"]["LocalAccountOperationModeEnum"]
> = ["disabled", "no-signup_hidden", "no-signup", "enabled"];
export const taskEnumValues: ReadonlyArray<components["schemas"]["TaskEnum"]> =
	["transcribe", "translate"];
export const transcriptTypeEnumValues: ReadonlyArray<
	components["schemas"]["TranscriptTypeEnum"]
> = ["as_txt", "as_srt", "as_tsv", "as_vtt", "as_json"];
export const userTypeEnumValues: ReadonlyArray<
	components["schemas"]["UserTypeEnum"]
> = ["local", "ldap", "oidc"];
